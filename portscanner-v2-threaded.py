import sys
import socket
import pyfiglet
import threading
import time
from queue import Queue

## Threading is still very confusing to me.  It took a lot of messy, failed compiles to get this working.
## and a lot of help from py-oneers that paved the way.  
## Will get to making a v3 and will push into multi-core technology utilization for an even faster portscan
## thanks for reading!

bannerscanner = pyfiglet.figlet_format(".DAVIDxBANNER.   .PORTxSCANNER.")
print(bannerscanner)

# translate to IPv4 in case hostname was input in a foolish way
target = socket.gethostbyname(sys.argv[1])
socket.setdefaulttimeout(1)

print("READING TARGET...")
print("*WHIRR*... BEEP...YES")
print("I FIND THE TARGET ACCEPTABLE. PORT MOLESTATION MAY NOW BEGIN.")

# CHECKIN ALL THEM PORTS, quick, stick, n, we skip (to the next one)
def portscan(port):
	try:
		s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		# and so we not hanging forever...

		result = s.connect((target, port))
	# don't let thread contention screw up printing
		print('{} is open'.format(port))
		if result == 0:
            print("PORT {} IS OPEN".format(port))
			s.close()
    except:
        pass

# threader thread pulls worker from queue and processes
def threader():
   while True:
      # gets worker from queue
      worker = q.get()
      # run job with savailable worker in queue (thread)
      portscan(worker)

      # complete with the job, shut down thread?
      q.task_done()

q = Queue()

#start tie
startTime = time.time()

for x in range(66):
	#Thread ID
	t = threading.Thread(target = threader)

	#classify as daemon, so they die when main dies
	t.daemon = True
	#begins - must come after daemon definition
	t.start()

for worker in range(1,65535):
	q.put(worker)

#wait til termination
q.join()

# ok, give us a final time report
runtime = float("%0.2f" % (time.time() - startTime))
print("Run Time: ", runtime, "seconds")
